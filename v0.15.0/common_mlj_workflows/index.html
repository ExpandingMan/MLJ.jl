<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common MLJ Workflows · MLJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">MLJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Common MLJ Workflows</a><ul class="internal"><li><a class="tocitem" href="#Data-ingestion-1"><span>Data ingestion</span></a></li><li><a class="tocitem" href="#Model-search-1"><span>Model search</span></a></li><li><a class="tocitem" href="#Instantiating-a-model-1"><span>Instantiating a model</span></a></li><li><a class="tocitem" href="#Evaluating-a-model-1"><span>Evaluating a model</span></a></li><li><a class="tocitem" href="#Basic-fit/evaluate/predict-by-hand:-1"><span>Basic fit/evaluate/predict by hand:</span></a></li><li><a class="tocitem" href="#More-performance-evaluation-examples-1"><span>More performance evaluation examples</span></a></li><li><a class="tocitem" href="#Inspecting-training-results-1"><span>Inspecting training results</span></a></li><li><a class="tocitem" href="#Basic-fit/transform-for-unsupervised-models-1"><span>Basic fit/transform for unsupervised models</span></a></li><li><a class="tocitem" href="#Inverting-learned-transformations-1"><span>Inverting learned transformations</span></a></li><li><a class="tocitem" href="#Nested-hyperparameter-tuning-1"><span>Nested hyperparameter tuning</span></a></li><li><a class="tocitem" href="#Constructing-a-linear-pipeline-1"><span>Constructing a linear pipeline</span></a></li><li><a class="tocitem" href="#Creating-a-homogeneous-ensemble-of-models-1"><span>Creating a homogeneous ensemble of models</span></a></li><li><a class="tocitem" href="#Performance-curves-1"><span>Performance curves</span></a></li></ul></li><li><a class="tocitem" href="../working_with_categorical_data/">Working with Categorical Data</a></li><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="tocitem" href="../performance_measures/">Performance Measures</a></li><li><a class="tocitem" href="../tuning_models/">Tuning Models</a></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li><a class="tocitem" href="../transformers/">Transformers and other unsupervised models</a></li><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="tocitem" href="../quick_start_guide_to_adding_models/">Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../list_of_supported_models/">List of Supported Models</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li><li><a class="tocitem" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li><li><a class="tocitem" href="../api/">Index of Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Common MLJ Workflows</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Common MLJ Workflows</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/common_mlj_workflows.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Common-MLJ-Workflows-1"><a class="docs-heading-anchor" href="#Common-MLJ-Workflows-1">Common MLJ Workflows</a><a class="docs-heading-anchor-permalink" href="#Common-MLJ-Workflows-1" title="Permalink"></a></h1><h2 id="Data-ingestion-1"><a class="docs-heading-anchor" href="#Data-ingestion-1">Data ingestion</a><a class="docs-heading-anchor-permalink" href="#Data-ingestion-1" title="Permalink"></a></h2><pre><code class="language-julia">import RDatasets
channing = RDatasets.dataset(&quot;boot&quot;, &quot;channing&quot;)
first(channing, 4)</code></pre><table class="data-frame"><thead><tr><th></th><th>Sex</th><th>Entry</th><th>Exit</th><th>Time</th><th>Cens</th></tr><tr><th></th><th>Cat…</th><th>Int32</th><th>Int32</th><th>Int32</th><th>Int32</th></tr></thead><tbody><p>4 rows × 5 columns</p><tr><th>1</th><td>Male</td><td>782</td><td>909</td><td>127</td><td>1</td></tr><tr><th>2</th><td>Male</td><td>1020</td><td>1128</td><td>108</td><td>1</td></tr><tr><th>3</th><td>Male</td><td>856</td><td>969</td><td>113</td><td>1</td></tr><tr><th>4</th><td>Male</td><td>915</td><td>957</td><td>42</td><td>1</td></tr></tbody></table><p>Inspecting metadata, including column scientific types:</p><pre><code class="language-julia">schema(channing)</code></pre><pre><code class="language-none">┌─────────┬────────────────────────────────┬───────────────┐
│ _.names │ _.types                        │ _.scitypes    │
├─────────┼────────────────────────────────┼───────────────┤
│ Sex     │ CategoricalValue{String,UInt8} │ Multiclass{2} │
│ Entry   │ Int32                          │ Count         │
│ Exit    │ Int32                          │ Count         │
│ Time    │ Int32                          │ Count         │
│ Cens    │ Int32                          │ Count         │
└─────────┴────────────────────────────────┴───────────────┘
_.nrows = 462
</code></pre><p>Unpacking data and correcting for wrong scitypes:</p><pre><code class="language-julia">y, X =  unpack(channing,
               ==(:Exit),            # y is the :Exit column
               !=(:Time);            # X is the rest, except :Time
               :Exit=&gt;Continuous,
               :Entry=&gt;Continuous,
               :Cens=&gt;Multiclass)
first(X, 4)</code></pre><table class="data-frame"><thead><tr><th></th><th>Sex</th><th>Entry</th><th>Cens</th></tr><tr><th></th><th>Cat…</th><th>Float64</th><th>Cat…</th></tr></thead><tbody><p>4 rows × 3 columns</p><tr><th>1</th><td>Male</td><td>782.0</td><td>1</td></tr><tr><th>2</th><td>Male</td><td>1020.0</td><td>1</td></tr><tr><th>3</th><td>Male</td><td>856.0</td><td>1</td></tr><tr><th>4</th><td>Male</td><td>915.0</td><td>1</td></tr></tbody></table><p><em>Note:</em> Before julia 1.2, replace <code>!=(:Time)</code> with <code>col -&gt; col != :Time</code>.</p><pre><code class="language-julia">y[1:4]</code></pre><pre><code class="language-none">4-element Array{Float64,1}:
  909.0
 1128.0
  969.0
  957.0</code></pre><p>Loading a built-in supervised dataset:</p><pre><code class="language-julia">X, y = @load_iris;
selectrows(X, 1:4) # selectrows works for any Tables.jl table</code></pre><pre><code class="language-none">(sepal_length = [5.1, 4.9, 4.7, 4.6],
 sepal_width = [3.5, 3.0, 3.2, 3.1],
 petal_length = [1.4, 1.4, 1.3, 1.5],
 petal_width = [0.2, 0.2, 0.2, 0.2],)</code></pre><pre><code class="language-julia">y[1:4]</code></pre><pre><code class="language-none">4-element CategoricalArray{String,1,UInt32}:
 &quot;setosa&quot;
 &quot;setosa&quot;
 &quot;setosa&quot;
 &quot;setosa&quot;</code></pre><h2 id="Model-search-1"><a class="docs-heading-anchor" href="#Model-search-1">Model search</a><a class="docs-heading-anchor-permalink" href="#Model-search-1" title="Permalink"></a></h2><p><em>Reference:</em>   <a href="../model_search/">Model Search</a></p><p>Searching for a supervised model:</p><pre><code class="language-julia">X, y = @load_boston
models(matching(X, y))</code></pre><pre><code class="language-none">57-element Array{NamedTuple{(:name, :package_name, :is_supervised, :docstring, :hyperparameter_ranges, :hyperparameter_types, :hyperparameters, :implemented_methods, :is_pure_julia, :is_wrapper, :load_path, :package_license, :package_url, :package_uuid, :prediction_type, :supports_online, :supports_weights, :input_scitype, :target_scitype, :output_scitype),T} where T&lt;:Tuple,1}:
 (name = ARDRegressor, package_name = ScikitLearn, ... )                
 (name = AdaBoostRegressor, package_name = ScikitLearn, ... )           
 (name = BaggingRegressor, package_name = ScikitLearn, ... )            
 (name = BayesianRidgeRegressor, package_name = ScikitLearn, ... )      
 (name = ConstantRegressor, package_name = MLJModels, ... )             
 (name = DecisionTreeRegressor, package_name = DecisionTree, ... )      
 (name = DeterministicConstantRegressor, package_name = MLJModels, ... )
 (name = DummyRegressor, package_name = ScikitLearn, ... )              
 (name = ElasticNetCVRegressor, package_name = ScikitLearn, ... )       
 (name = ElasticNetRegressor, package_name = MLJLinearModels, ... )     
 ⋮                                                                      
 (name = RidgeRegressor, package_name = MultivariateStats, ... )        
 (name = RidgeRegressor, package_name = ScikitLearn, ... )              
 (name = RobustRegressor, package_name = MLJLinearModels, ... )         
 (name = SGDRegressor, package_name = ScikitLearn, ... )                
 (name = SVMLinearRegressor, package_name = ScikitLearn, ... )          
 (name = SVMNuRegressor, package_name = ScikitLearn, ... )              
 (name = SVMRegressor, package_name = ScikitLearn, ... )                
 (name = TheilSenRegressor, package_name = ScikitLearn, ... )           
 (name = XGBoostRegressor, package_name = XGBoost, ... )                </code></pre><pre><code class="language-julia">models(matching(X, y))[6]</code></pre><pre><code class="language-none">CART decision tree regressor.
→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).
→ do `@load DecisionTreeRegressor pkg=&quot;DecisionTree&quot;` to use the model.
→ do `?DecisionTreeRegressor` for documentation.
(name = &quot;DecisionTreeRegressor&quot;,
 package_name = &quot;DecisionTree&quot;,
 is_supervised = true,
 docstring = &quot;CART decision tree regressor.\n→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).\n→ do `@load DecisionTreeRegressor pkg=\&quot;DecisionTree\&quot;` to use the model.\n→ do `?DecisionTreeRegressor` for documentation.&quot;,
 hyperparameter_ranges = (nothing, nothing, nothing, nothing, nothing, nothing, nothing),
 hyperparameter_types = (&quot;Int64&quot;, &quot;Int64&quot;, &quot;Int64&quot;, &quot;Float64&quot;, &quot;Int64&quot;, &quot;Bool&quot;, &quot;Float64&quot;),
 hyperparameters = (:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :post_prune, :merge_purity_threshold),
 implemented_methods = Symbol[:predict, :clean!, :fit, :fitted_params],
 is_pure_julia = true,
 is_wrapper = false,
 load_path = &quot;MLJDecisionTreeInterface.DecisionTreeRegressor&quot;,
 package_license = &quot;MIT&quot;,
 package_url = &quot;https://github.com/bensadeghi/DecisionTree.jl&quot;,
 package_uuid = &quot;7806a523-6efd-50cb-b5f6-3fa6f1930dbb&quot;,
 prediction_type = :deterministic,
 supports_online = false,
 supports_weights = false,
 input_scitype = Table{_s24} where _s24&lt;:Union{AbstractArray{_s23,1} where _s23&lt;:Continuous, AbstractArray{_s23,1} where _s23&lt;:Count, AbstractArray{_s23,1} where _s23&lt;:OrderedFactor},
 target_scitype = AbstractArray{Continuous,1},
 output_scitype = Unknown,)</code></pre><p>More refined searches:</p><pre><code class="language-julia">models() do model
    matching(model, X, y) &amp;&amp;
    model.prediction_type == :deterministic &amp;&amp;
    model.is_pure_julia
end</code></pre><pre><code class="language-none">18-element Array{NamedTuple{(:name, :package_name, :is_supervised, :docstring, :hyperparameter_ranges, :hyperparameter_types, :hyperparameters, :implemented_methods, :is_pure_julia, :is_wrapper, :load_path, :package_license, :package_url, :package_uuid, :prediction_type, :supports_online, :supports_weights, :input_scitype, :target_scitype, :output_scitype),T} where T&lt;:Tuple,1}:
 (name = DecisionTreeRegressor, package_name = DecisionTree, ... )        
 (name = DeterministicConstantRegressor, package_name = MLJModels, ... )  
 (name = ElasticNetRegressor, package_name = MLJLinearModels, ... )       
 (name = EvoTreeRegressor, package_name = EvoTrees, ... )                 
 (name = HuberRegressor, package_name = MLJLinearModels, ... )            
 (name = KNNRegressor, package_name = NearestNeighbors, ... )             
 (name = KPLSRegressor, package_name = PartialLeastSquaresRegressor, ... )
 (name = LADRegressor, package_name = MLJLinearModels, ... )              
 (name = LassoRegressor, package_name = MLJLinearModels, ... )            
 (name = LinearRegressor, package_name = MLJLinearModels, ... )           
 (name = LinearRegressor, package_name = MultivariateStats, ... )         
 (name = NeuralNetworkRegressor, package_name = MLJFlux, ... )            
 (name = PLSRegressor, package_name = PartialLeastSquaresRegressor, ... ) 
 (name = QuantileRegressor, package_name = MLJLinearModels, ... )         
 (name = RandomForestRegressor, package_name = DecisionTree, ... )        
 (name = RidgeRegressor, package_name = MLJLinearModels, ... )            
 (name = RidgeRegressor, package_name = MultivariateStats, ... )          
 (name = RobustRegressor, package_name = MLJLinearModels, ... )           </code></pre><p>Searching for an unsupervised model:</p><pre><code class="language-julia">models(matching(X))</code></pre><pre><code class="language-none">24-element Array{NamedTuple{(:name, :package_name, :is_supervised, :docstring, :hyperparameter_ranges, :hyperparameter_types, :hyperparameters, :implemented_methods, :is_pure_julia, :is_wrapper, :load_path, :package_license, :package_url, :package_uuid, :prediction_type, :supports_online, :supports_weights, :input_scitype, :target_scitype, :output_scitype),T} where T&lt;:Tuple,1}:
 (name = AffinityPropagation, package_name = ScikitLearn, ... )    
 (name = AgglomerativeClustering, package_name = ScikitLearn, ... )
 (name = Birch, package_name = ScikitLearn, ... )                  
 (name = ContinuousEncoder, package_name = MLJModels, ... )        
 (name = DBSCAN, package_name = ScikitLearn, ... )                 
 (name = FactorAnalysis, package_name = MultivariateStats, ... )   
 (name = FeatureAgglomeration, package_name = ScikitLearn, ... )   
 (name = FeatureSelector, package_name = MLJModels, ... )          
 (name = FillImputer, package_name = MLJModels, ... )              
 (name = ICA, package_name = MultivariateStats, ... )              
 ⋮                                                                 
 (name = MeanShift, package_name = ScikitLearn, ... )              
 (name = MiniBatchKMeans, package_name = ScikitLearn, ... )        
 (name = OPTICS, package_name = ScikitLearn, ... )                 
 (name = OneClassSVM, package_name = LIBSVM, ... )                 
 (name = OneHotEncoder, package_name = MLJModels, ... )            
 (name = PCA, package_name = MultivariateStats, ... )              
 (name = PPCA, package_name = MultivariateStats, ... )             
 (name = SpectralClustering, package_name = ScikitLearn, ... )     
 (name = Standardizer, package_name = MLJModels, ... )             </code></pre><p>Getting the metadata entry for a given model type:</p><pre><code class="language-julia">info(&quot;PCA&quot;)
info(&quot;RidgeRegressor&quot;, pkg=&quot;MultivariateStats&quot;) # a model type in multiple packages</code></pre><pre><code class="language-none">Ridge regressor with regularization parameter lambda. Learns a
linear regression with a penalty on the l2 norm of the coefficients.

→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).
→ do `@load RidgeRegressor pkg=&quot;MultivariateStats&quot;` to use the model.
→ do `?RidgeRegressor` for documentation.
(name = &quot;RidgeRegressor&quot;,
 package_name = &quot;MultivariateStats&quot;,
 is_supervised = true,
 docstring = &quot;Ridge regressor with regularization parameter lambda. Learns a\nlinear regression with a penalty on the l2 norm of the coefficients.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load RidgeRegressor pkg=\&quot;MultivariateStats\&quot;` to use the model.\n→ do `?RidgeRegressor` for documentation.&quot;,
 hyperparameter_ranges = (nothing, nothing),
 hyperparameter_types = (&quot;Union{Real, Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}&quot;, &quot;Bool&quot;),
 hyperparameters = (:lambda, :bias),
 implemented_methods = Symbol[:predict, :clean!, :fit, :fitted_params],
 is_pure_julia = true,
 is_wrapper = false,
 load_path = &quot;MLJMultivariateStatsInterface.RidgeRegressor&quot;,
 package_license = &quot;MIT&quot;,
 package_url = &quot;https://github.com/JuliaStats/MultivariateStats.jl&quot;,
 package_uuid = &quot;6f286f6a-111f-5878-ab1e-185364afe411&quot;,
 prediction_type = :deterministic,
 supports_online = false,
 supports_weights = false,
 input_scitype = Table{_s24} where _s24&lt;:(AbstractArray{_s23,1} where _s23&lt;:Continuous),
 target_scitype = Union{AbstractArray{Continuous,1}, Table{_s24} where _s24&lt;:(AbstractArray{_s23,1} where _s23&lt;:Continuous)},
 output_scitype = Unknown,)</code></pre><h2 id="Instantiating-a-model-1"><a class="docs-heading-anchor" href="#Instantiating-a-model-1">Instantiating a model</a><a class="docs-heading-anchor-permalink" href="#Instantiating-a-model-1" title="Permalink"></a></h2><p><em>Reference:</em>   <a href="../">Getting Started</a></p><pre><code class="language-julia">@load DecisionTreeClassifier
model = DecisionTreeClassifier(min_samples_split=5, max_depth=4)</code></pre><pre><code class="language-none">DecisionTreeClassifier(
    max_depth = 4,
    min_samples_leaf = 1,
    min_samples_split = 5,
    min_purity_increase = 0.0,
    n_subfeatures = 0,
    post_prune = false,
    merge_purity_threshold = 1.0,
    pdf_smoothing = 0.0,
    display_depth = 5) @957</code></pre><p>or</p><pre><code class="language-">model = @load DecisionTreeClassifier
model.min_samples_split = 5
model.max_depth = 4</code></pre><h2 id="Evaluating-a-model-1"><a class="docs-heading-anchor" href="#Evaluating-a-model-1">Evaluating a model</a><a class="docs-heading-anchor-permalink" href="#Evaluating-a-model-1" title="Permalink"></a></h2><p><em>Reference:</em>   <a href="../evaluating_model_performance/">Evaluating Model Performance</a></p><pre><code class="language-julia">X, y = @load_boston
model = @load KNNRegressor
evaluate(model, X, y, resampling=CV(nfolds=5), measure=[rms, mav])</code></pre><pre><code class="language-none">┌───────────────────────────┬───────────────┬───────────────────────────────┐
│ _.measure                 │ _.measurement │ _.per_fold                    │
├───────────────────────────┼───────────────┼───────────────────────────────┤
│ RootMeanSquaredError @125 │ 8.77          │ [8.53, 8.8, 10.7, 9.43, 5.59] │
│ MeanAbsoluteError @828    │ 6.02          │ [6.52, 5.7, 7.65, 6.09, 4.11] │
└───────────────────────────┴───────────────┴───────────────────────────────┘
_.per_observation = [missing, missing]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><h2 id="Basic-fit/evaluate/predict-by-hand:-1"><a class="docs-heading-anchor" href="#Basic-fit/evaluate/predict-by-hand:-1">Basic fit/evaluate/predict by hand:</a><a class="docs-heading-anchor-permalink" href="#Basic-fit/evaluate/predict-by-hand:-1" title="Permalink"></a></h2><p><em>Reference:</em>   <a href="../">Getting Started</a>, <a href="../machines/">Machines</a>, <a href="../evaluating_model_performance/">Evaluating Model Performance</a>, <a href="../performance_measures/">Performance Measures</a></p><pre><code class="language-julia">import RDatasets
vaso = RDatasets.dataset(&quot;robustbase&quot;, &quot;vaso&quot;); # a DataFrame
first(vaso, 3)</code></pre><table class="data-frame"><thead><tr><th></th><th>Volume</th><th>Rate</th><th>Y</th></tr><tr><th></th><th>Float64</th><th>Float64</th><th>Int64</th></tr></thead><tbody><p>3 rows × 3 columns</p><tr><th>1</th><td>3.7</td><td>0.825</td><td>1</td></tr><tr><th>2</th><td>3.5</td><td>1.09</td><td>1</td></tr><tr><th>3</th><td>1.25</td><td>2.5</td><td>1</td></tr></tbody></table><pre><code class="language-julia">y, X = unpack(vaso, ==(:Y), c -&gt; true; :Y =&gt; Multiclass)

tree_model = @load DecisionTreeClassifier</code></pre><pre><code class="language-none">[ Info: For silent loading, specify `verbosity=0`.
[ Info: Model code for DecisionTreeClassifier already loaded
(MLJDecisionTreeInterface.DecisionTreeClassifier)() ✔</code></pre><p>Bind the model and data together in a <em>machine</em> , which will additionally store the learned parameters (<em>fitresults</em>) when fit:</p><pre><code class="language-julia">tree = machine(tree_model, X, y)</code></pre><pre><code class="language-none">Machine{DecisionTreeClassifier} @190 trained 0 times.
  args: 
    1:	Source @453 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @608 ⏎ `AbstractArray{Multiclass{2},1}`
</code></pre><p>Split row indices into training and evaluation rows:</p><pre><code class="language-julia">train, test = partition(eachindex(y), 0.7, shuffle=true, rng=1234); # 70:30 split</code></pre><pre><code class="language-none">([27, 28, 30, 31, 32, 18, 21, 9, 26, 14  …  7, 39, 2, 37, 1, 8, 19, 25, 35, 34], [22, 13, 11, 4, 10, 16, 3, 20, 29, 23, 12, 24])</code></pre><p>Fit on train and evaluate on test:</p><pre><code class="language-julia">fit!(tree, rows=train)
yhat = predict(tree, X[test,:])
mean(cross_entropy(yhat, y[test]))</code></pre><pre><code class="language-none">6.5216583816514975</code></pre><p>Predict on new data:</p><pre><code class="language-julia">Xnew = (Volume=3*rand(3), Rate=3*rand(3))
predict(tree, Xnew)      # a vector of distributions</code></pre><pre><code class="language-none">3-element MLJBase.UnivariateFiniteArray{Multiclass{2},Int64,UInt32,Float64,1}:
 UnivariateFinite{Multiclass{2}}(0=&gt;0.273, 1=&gt;0.727)
 UnivariateFinite{Multiclass{2}}(0=&gt;0.0, 1=&gt;1.0)    
 UnivariateFinite{Multiclass{2}}(0=&gt;0.9, 1=&gt;0.1)    </code></pre><pre><code class="language-julia">predict_mode(tree, Xnew) # a vector of point-predictions</code></pre><pre><code class="language-none">3-element CategoricalArray{Int64,1,UInt32}:
 1
 1
 0</code></pre><h2 id="More-performance-evaluation-examples-1"><a class="docs-heading-anchor" href="#More-performance-evaluation-examples-1">More performance evaluation examples</a><a class="docs-heading-anchor-permalink" href="#More-performance-evaluation-examples-1" title="Permalink"></a></h2><pre><code class="language-julia">import LossFunctions.ZeroOneLoss</code></pre><p>Evaluating model + data directly:</p><pre><code class="language-julia">evaluate(tree_model, X, y,
         resampling=Holdout(fraction_train=0.7, shuffle=true, rng=1234),
         measure=[cross_entropy, ZeroOneLoss()])</code></pre><pre><code class="language-none">┌───────────────────────┬───────────────┬────────────┐
│ _.measure             │ _.measurement │ _.per_fold │
├───────────────────────┼───────────────┼────────────┤
│ LogLoss{Float64} @340 │ 6.52          │ [6.52]     │
│ ZeroOneLoss           │ 0.417         │ [0.417]    │
└───────────────────────┴───────────────┴────────────┘
_.per_observation = [[[0.105, 36.0, ..., 1.3]], [[0.0, 1.0, ..., 1.0]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><p>If a machine is already defined, as above:</p><pre><code class="language-julia">evaluate!(tree,
          resampling=Holdout(fraction_train=0.7, shuffle=true, rng=1234),
          measure=[cross_entropy, ZeroOneLoss()])</code></pre><pre><code class="language-none">┌───────────────────────┬───────────────┬────────────┐
│ _.measure             │ _.measurement │ _.per_fold │
├───────────────────────┼───────────────┼────────────┤
│ LogLoss{Float64} @340 │ 6.52          │ [6.52]     │
│ ZeroOneLoss           │ 0.417         │ [0.417]    │
└───────────────────────┴───────────────┴────────────┘
_.per_observation = [[[0.105, 36.0, ..., 1.3]], [[0.0, 1.0, ..., 1.0]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><p>Using cross-validation:</p><pre><code class="language-julia">evaluate!(tree, resampling=CV(nfolds=5, shuffle=true, rng=1234),
          measure=[cross_entropy, ZeroOneLoss()])</code></pre><pre><code class="language-none">┌───────────────────────┬───────────────┬───────────────────────────────────┐
│ _.measure             │ _.measurement │ _.per_fold                        │
├───────────────────────┼───────────────┼───────────────────────────────────┤
│ LogLoss{Float64} @340 │ 2.47          │ [9.25, 0.598, 0.912, 1.07, 0.546] │
│ ZeroOneLoss           │ 0.432         │ [0.5, 0.375, 0.5, 0.5, 0.286]     │
└───────────────────────┴───────────────┴───────────────────────────────────┘
_.per_observation = [[[2.22e-16, 0.944, ..., 2.22e-16], [0.847, 0.56, ..., 0.56], [0.194, 2.22e-16, ..., 0.223], [2.01, 2.01, ..., 0.143], [0.405, 0.405, ..., 1.1]], [[0.0, 1.0, ..., 0.0], [1.0, 0.0, ..., 0.0], [0.0, 0.0, ..., 0.0], [1.0, 1.0, ..., 0.0], [0.0, 0.0, ..., 1.0]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><p>With user-specified train/test pairs of row indices:</p><pre><code class="language-julia">f1, f2, f3 = 1:13, 14:26, 27:36
pairs = [(f1, vcat(f2, f3)), (f2, vcat(f3, f1)), (f3, vcat(f1, f2))];
evaluate!(tree,
          resampling=pairs,
          measure=[cross_entropy, ZeroOneLoss()])</code></pre><pre><code class="language-none">┌───────────────────────┬───────────────┬───────────────────────┐
│ _.measure             │ _.measurement │ _.per_fold            │
├───────────────────────┼───────────────┼───────────────────────┤
│ LogLoss{Float64} @340 │ 5.88          │ [2.16, 11.0, 4.51]    │
│ ZeroOneLoss           │ 0.241         │ [0.304, 0.304, 0.115] │
└───────────────────────┴───────────────┴───────────────────────┘
_.per_observation = [[[0.154, 0.154, ..., 0.154], [2.22e-16, 36.0, ..., 2.22e-16], [2.22e-16, 2.22e-16, ..., 0.693]], [[0.0, 0.0, ..., 0.0], [0.0, 1.0, ..., 0.0], [0.0, 0.0, ..., 0.0]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><p>Changing a hyperparameter and re-evaluating:</p><pre><code class="language-julia">tree_model.max_depth = 3
evaluate!(tree,
          resampling=CV(nfolds=5, shuffle=true, rng=1234),
          measure=[cross_entropy, ZeroOneLoss()])</code></pre><pre><code class="language-none">┌───────────────────────┬───────────────┬────────────────────────────────────┐
│ _.measure             │ _.measurement │ _.per_fold                         │
├───────────────────────┼───────────────┼────────────────────────────────────┤
│ LogLoss{Float64} @340 │ 2.23          │ [9.18, 0.484, 0.427, 0.564, 0.488] │
│ ZeroOneLoss           │ 0.307         │ [0.375, 0.25, 0.25, 0.375, 0.286]  │
└───────────────────────┴───────────────┴────────────────────────────────────┘
_.per_observation = [[[2.22e-16, 1.32, ..., 2.22e-16], [2.22e-16, 0.318, ..., 0.318], [0.405, 2.22e-16, ..., 2.22e-16], [1.5, 1.5, ..., 2.22e-16], [0.636, 2.22e-16, ..., 0.754]], [[0.0, 1.0, ..., 0.0], [0.0, 0.0, ..., 0.0], [0.0, 0.0, ..., 0.0], [1.0, 1.0, ..., 0.0], [0.0, 0.0, ..., 1.0]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><h2 id="Inspecting-training-results-1"><a class="docs-heading-anchor" href="#Inspecting-training-results-1">Inspecting training results</a><a class="docs-heading-anchor-permalink" href="#Inspecting-training-results-1" title="Permalink"></a></h2><p>Fit a ordinary least square model to some synthetic data:</p><pre><code class="language-julia">x1 = rand(100)
x2 = rand(100)

X = (x1=x1, x2=x2)
y = x1 - 2x2 + 0.1*rand(100);

ols_model = @load LinearRegressor pkg=GLM
ols =  machine(ols_model, X, y)
fit!(ols)</code></pre><pre><code class="language-none">Machine{LinearRegressor} @011 trained 1 time.
  args: 
    1:	Source @217 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @525 ⏎ `AbstractArray{Continuous,1}`
</code></pre><p>Get a named tuple representing the learned parameters, human-readable if appropriate:</p><pre><code class="language-julia">fitted_params(ols)</code></pre><pre><code class="language-none">(coef = [0.9946466649694611, -1.9951872369738228],
 intercept = 0.049599217067821326,)</code></pre><p>Get other training-related information:</p><pre><code class="language-julia">report(ols)</code></pre><pre><code class="language-none">(deviance = 0.07763653531852567,
 dof_residual = 97.0,
 stderror = [0.010522935534016146, 0.009645977061540157, 0.007493085171651995],
 vcov = [0.00011073217225305967 -3.2816523123439564e-6 -5.0331675780488734e-5; -3.2816523123439564e-6 9.304487347175887e-5 -4.6967893675902655e-5; -5.0331675780488734e-5 -4.6967893675902655e-5 5.6146325389631005e-5],)</code></pre><h2 id="Basic-fit/transform-for-unsupervised-models-1"><a class="docs-heading-anchor" href="#Basic-fit/transform-for-unsupervised-models-1">Basic fit/transform for unsupervised models</a><a class="docs-heading-anchor-permalink" href="#Basic-fit/transform-for-unsupervised-models-1" title="Permalink"></a></h2><p>Load data:</p><pre><code class="language-julia">X, y = @load_iris
train, test = partition(eachindex(y), 0.97, shuffle=true, rng=123)</code></pre><pre><code class="language-none">([125, 100, 130, 9, 70, 148, 39, 64, 6, 107  …  110, 59, 139, 21, 112, 144, 140, 72, 109, 41], [106, 147, 47, 5])</code></pre><p>Instantiate and fit the model/machine:</p><pre><code class="language-julia">@load PCA
pca_model = PCA(maxoutdim=2)
pca = machine(pca_model, X)
fit!(pca, rows=train)</code></pre><pre><code class="language-none">Machine{PCA} @303 trained 1 time.
  args: 
    1:	Source @986 ⏎ `Table{AbstractArray{Continuous,1}}`
</code></pre><p>Transform selected data bound to the machine:</p><pre><code class="language-julia">transform(pca, rows=test);</code></pre><pre><code class="language-none">(x1 = [-3.3942826854483243, -1.5219827578765068, 2.538247455185219, 2.7299639893931373],
 x2 = [0.5472450223745241, -0.36842368617126214, 0.5199299511335698, 0.3448466122232363],)</code></pre><p>Transform new data:</p><pre><code class="language-julia">Xnew = (sepal_length=rand(3), sepal_width=rand(3),
        petal_length=rand(3), petal_width=rand(3));
transform(pca, Xnew)</code></pre><pre><code class="language-none">(x1 = [4.6161081766120144, 4.63369061978829, 4.887816299705566],
 x2 = [-4.692915918162014, -4.837717203101405, -5.030597498324413],)</code></pre><h2 id="Inverting-learned-transformations-1"><a class="docs-heading-anchor" href="#Inverting-learned-transformations-1">Inverting learned transformations</a><a class="docs-heading-anchor-permalink" href="#Inverting-learned-transformations-1" title="Permalink"></a></h2><pre><code class="language-julia">y = rand(100);
stand_model = UnivariateStandardizer()
stand = machine(stand_model, y)
fit!(stand)
z = transform(stand, y);
@assert inverse_transform(stand, z) ≈ y # true</code></pre><pre><code class="language-none">[ Info: Training Machine{UnivariateStandardizer} @786.</code></pre><h2 id="Nested-hyperparameter-tuning-1"><a class="docs-heading-anchor" href="#Nested-hyperparameter-tuning-1">Nested hyperparameter tuning</a><a class="docs-heading-anchor-permalink" href="#Nested-hyperparameter-tuning-1" title="Permalink"></a></h2><p><em>Reference:</em>   <a href="../tuning_models/">Tuning Models</a></p><p>Define a model with nested hyperparameters:</p><pre><code class="language-julia">tree_model = @load DecisionTreeClassifier
forest_model = EnsembleModel(atom=tree_model, n=300)</code></pre><pre><code class="language-none">ProbabilisticEnsembleModel(
    atom = DecisionTreeClassifier(
            max_depth = -1,
            min_samples_leaf = 1,
            min_samples_split = 2,
            min_purity_increase = 0.0,
            n_subfeatures = 0,
            post_prune = false,
            merge_purity_threshold = 1.0,
            pdf_smoothing = 0.0,
            display_depth = 5),
    atomic_weights = Float64[],
    bagging_fraction = 0.8,
    rng = MersenneTwister(UInt32[0xd8ddedb6, 0xf42515f5, 0xb57a37f6, 0xa551554d]) @ 172,
    n = 300,
    acceleration = CPU1{Nothing}(nothing),
    out_of_bag_measure = Any[]) @150</code></pre><p>Inspect all hyperparameters, even nested ones (returns nested named tuple):</p><pre><code class="language-julia">params(forest_model)</code></pre><pre><code class="language-none">(atom = (max_depth = -1,
         min_samples_leaf = 1,
         min_samples_split = 2,
         min_purity_increase = 0.0,
         n_subfeatures = 0,
         post_prune = false,
         merge_purity_threshold = 1.0,
         pdf_smoothing = 0.0,
         display_depth = 5,),
 atomic_weights = Float64[],
 bagging_fraction = 0.8,
 rng = MersenneTwister(UInt32[0xd8ddedb6, 0xf42515f5, 0xb57a37f6, 0xa551554d]) @ 172,
 n = 300,
 acceleration = CPU1{Nothing}(nothing),
 out_of_bag_measure = Any[],)</code></pre><p>Define ranges for hyperparameters to be tuned:</p><pre><code class="language-julia">r1 = range(forest_model, :bagging_fraction, lower=0.5, upper=1.0, scale=:log10)</code></pre><pre><code class="language-none">MLJBase.NumericRange(Float64, :bagging_fraction, ... )</code></pre><pre><code class="language-julia">r2 = range(forest_model, :(atom.n_subfeatures), lower=1, upper=4) # nested</code></pre><pre><code class="language-none">MLJBase.NumericRange(Int64, :(atom.n_subfeatures), ... )</code></pre><p>Wrap the model in a tuning strategy:</p><pre><code class="language-julia">tuned_forest = TunedModel(model=forest_model,
                          tuning=Grid(resolution=12),
                          resampling=CV(nfolds=6),
                          ranges=[r1, r2],
                          measure=cross_entropy)</code></pre><pre><code class="language-none">ProbabilisticTunedModel(
    model = ProbabilisticEnsembleModel(
            atom = DecisionTreeClassifier @768,
            atomic_weights = Float64[],
            bagging_fraction = 0.8,
            rng = MersenneTwister(UInt32[0xd8ddedb6, 0xf42515f5, 0xb57a37f6, 0xa551554d]) @ 172,
            n = 300,
            acceleration = CPU1{Nothing}(nothing),
            out_of_bag_measure = Any[]),
    tuning = Grid(
            goal = nothing,
            resolution = 12,
            shuffle = true,
            rng = MersenneTwister(UInt32[0xd8ddedb6, 0xf42515f5, 0xb57a37f6, 0xa551554d]) @ 172),
    resampling = CV(
            nfolds = 6,
            shuffle = false,
            rng = MersenneTwister(UInt32[0xd8ddedb6, 0xf42515f5, 0xb57a37f6, 0xa551554d]) @ 172),
    measure = LogLoss(
            tol = 2.220446049250313e-16),
    weights = nothing,
    operation = MLJModelInterface.predict,
    range = MLJBase.NumericRange{T,MLJBase.Bounded,Symbol} where T[NumericRange{Float64,…} @398, NumericRange{Int64,…} @721],
    selection_heuristic = MLJTuning.NaiveSelection(nothing),
    train_best = true,
    repeats = 1,
    n = nothing,
    acceleration = CPU1{Nothing}(nothing),
    acceleration_resampling = CPU1{Nothing}(nothing),
    check_measure = true) @813</code></pre><p>Bound the wrapped model to data:</p><pre><code class="language-julia">tuned = machine(tuned_forest, X, y)</code></pre><pre><code class="language-none">Machine{ProbabilisticTunedModel{Grid,…}} @979 trained 0 times.
  args: 
    1:	Source @494 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @839 ⏎ `AbstractArray{Multiclass{3},1}`
</code></pre><p>Fitting the resultant machine optimizes the hyperparameters specified in <code>range</code>, using the specified <code>tuning</code> and <code>resampling</code> strategies and performance <code>measure</code> (possibly a vector of measures), and retrains on all data bound to the machine:</p><pre><code class="language-julia">fit!(tuned)</code></pre><pre><code class="language-none">Machine{ProbabilisticTunedModel{Grid,…}} @979 trained 1 time.
  args: 
    1:	Source @494 ⏎ `Table{AbstractArray{Continuous,1}}`
    2:	Source @839 ⏎ `AbstractArray{Multiclass{3},1}`
</code></pre><p>Inspecting the optimal model:</p><pre><code class="language-julia">F = fitted_params(tuned)</code></pre><pre><code class="language-none">(best_model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @214,
 best_fitted_params = (fitresult = WrappedEnsemble{Tuple{Node{Float64,…},…},…} @344,),)</code></pre><pre><code class="language-julia">F.best_model</code></pre><pre><code class="language-none">ProbabilisticEnsembleModel(
    atom = DecisionTreeClassifier(
            max_depth = -1,
            min_samples_leaf = 1,
            min_samples_split = 2,
            min_purity_increase = 0.0,
            n_subfeatures = 3,
            post_prune = false,
            merge_purity_threshold = 1.0,
            pdf_smoothing = 0.0,
            display_depth = 5),
    atomic_weights = Float64[],
    bagging_fraction = 0.5,
    rng = MersenneTwister(UInt32[0xd8ddedb6, 0xf42515f5, 0xb57a37f6, 0xa551554d]) @ 834,
    n = 300,
    acceleration = CPU1{Nothing}(nothing),
    out_of_bag_measure = Any[]) @214</code></pre><p>Inspecting details of tuning procedure:</p><pre><code class="language-julia">report(tuned)</code></pre><pre><code class="language-none">(best_model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @214,
 best_history_entry = (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @214,
                       measure = LogLoss{Float64}[LogLoss{Float64} @340],
                       measurement = [0.14913339088257035],
                       per_fold = Array{Float64,1}[[3.663735981263026e-15, 3.663735981263026e-15, 0.21568857983641876, 0.21518797082255228, 0.23350960062649237, 0.23041419400995142]],),
 history = NamedTuple{(:model, :measure, :measurement, :per_fold),Tuple{MLJ.ProbabilisticEnsembleModel{MLJDecisionTreeInterface.DecisionTreeClassifier},Array{LogLoss{Float64},1},Array{Float64,1},Array{Array{Float64,1},1}}}[(model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @547, measure = [LogLoss{Float64} @340], measurement = [0.20770637554108998], per_fold = [[0.025225540727701383, 0.004106730330549687, 0.29757114317078026, 0.2860429984607888, 0.34970792540694, 0.2835839151497798]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @295, measure = [LogLoss{Float64} @340], measurement = [0.20721158176223298], per_fold = [[0.07111994675927286, 0.030749861294096688, 0.3145600093924827, 0.2662217824647754, 0.28332763194121324, 0.277290258721557]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @355, measure = [LogLoss{Float64} @340], measurement = [0.18723764335782758], per_fold = [[0.0285393683807929, 0.004489689932346698, 0.25995076328679667, 0.2836373907071307, 0.2951136107889083, 0.2516950370509903]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @274, measure = [LogLoss{Float64} @340], measurement = [0.4230149413637956], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.28084365412051104, 0.37253681233204505, 1.5566825157092938, 0.32802666602091635]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @265, measure = [LogLoss{Float64} @340], measurement = [0.44601716195082036], per_fold = [[0.025420079808502374, 0.0046696286068946165, 0.34776041487872594, 0.39887644356346125, 1.5809014462339872, 0.31847495861335057]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @989, measure = [LogLoss{Float64} @340], measurement = [0.21011167867870154], per_fold = [[0.07332027942350758, 0.03348259735653938, 0.3286967967848075, 0.2524934874624888, 0.2856551358602323, 0.28702177518463357]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @356, measure = [LogLoss{Float64} @340], measurement = [0.1790500254373516], per_fold = [[0.03233050045415726, 0.006645134162157615, 0.2297685755925921, 0.27943939541751517, 0.28186208590930084, 0.24425446108838653]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @332, measure = [LogLoss{Float64} @340], measurement = [0.1625963347554709], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.2291590511001322, 0.25927709408553706, 0.23067618157505546, 0.25646568177209345]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @676, measure = [LogLoss{Float64} @340], measurement = [0.16089815217836523], per_fold = [[0.02945767982788143, 0.010711318320359813, 0.22848922202903166, 0.2270119956776867, 0.24102730371021178, 0.22869139350501994]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @053, measure = [LogLoss{Float64} @340], measurement = [0.15315132833310383], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.21647470781838737, 0.22856331342907216, 0.23523798165895882, 0.23863196709219728]])  …  (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @667, measure = [LogLoss{Float64} @340], measurement = [0.17805117148922014], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.2149621732524432, 0.33981218815560715, 0.2509253773670505, 0.2626072901602128]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @588, measure = [LogLoss{Float64} @340], measurement = [0.40742662458088996], per_fold = [[0.04230321098755611, 0.013434395008672963, 0.25791510414577823, 0.24933149252424014, 1.5530771038225077, 0.3284984409965845]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @803, measure = [LogLoss{Float64} @340], measurement = [0.19764182625160787], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.26292238259304634, 0.35054684063168706, 0.283420840403728, 0.28896089388117857]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @256, measure = [LogLoss{Float64} @340], measurement = [0.20421572333155955], per_fold = [[0.05753132376997679, 0.01921335470968998, 0.30185003085977735, 0.24942444702314595, 0.28807803355828154, 0.3091971500684856]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @740, measure = [LogLoss{Float64} @340], measurement = [0.2257354776015752], per_fold = [[0.027411826777586894, 0.004766588789698611, 0.30780745882900434, 0.3752487650037121, 0.34525020639872195, 0.29392801981072725]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @500, measure = [LogLoss{Float64} @340], measurement = [0.21291460709056406], per_fold = [[0.07094820327579499, 0.02613824191683983, 0.30147443034436294, 0.25579370384273425, 0.3191563965631846, 0.3039766666004677]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @627, measure = [LogLoss{Float64} @340], measurement = [0.8738950434691818], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 1.5883210707050162, 1.674040807201203, 1.6011113045926022, 0.37989707831626207]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @515, measure = [LogLoss{Float64} @340], measurement = [0.18684000409219284], per_fold = [[0.03215703174897974, 0.008357640892705133, 0.24583834583808858, 0.2733562300598107, 0.3144485960191818, 0.24688217999439122]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @059, measure = [LogLoss{Float64} @340], measurement = [0.21674808251576771], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.30368232290874436, 0.37541170986103756, 0.33919238691092085, 0.2822020754138962]]), (model = ProbabilisticEnsembleModel{DecisionTreeClassifier} @468, measure = [LogLoss{Float64} @340], measurement = [0.16033536220846334], per_fold = [[3.663735981263026e-15, 3.663735981263026e-15, 0.21076289246466526, 0.2854694438245955, 0.21706570259195615, 0.24871413436955578]])],
 best_report = (measures = Any[],
                oob_measurements = missing,),
 plotting = (parameter_names = [&quot;bagging_fraction&quot;, &quot;atom.n_subfeatures&quot;],
             parameter_scales = Symbol[:log10, :linear],
             parameter_values = Any[0.8277532798848107 2; 0.5671562610977313 1; … ; 0.7772031408854596 3; 0.5671562610977313 3],
             measurements = [0.20770637554108998, 0.20721158176223298, 0.18723764335782758, 0.4230149413637956, 0.44601716195082036, 0.21011167867870154, 0.1790500254373516, 0.1625963347554709, 0.16089815217836523, 0.15315132833310383  …  0.17805117148922014, 0.40742662458088996, 0.19764182625160787, 0.20421572333155955, 0.2257354776015752, 0.21291460709056406, 0.8738950434691818, 0.18684000409219284, 0.21674808251576771, 0.16033536220846334],),)</code></pre><p>Visualizing these results:</p><pre><code class="language-julia">using Plots
plot(tuned)</code></pre><p><img src="../img/workflows_tuning_plot.png" alt/></p><p>Predicting on new data using the optimized model:</p><pre><code class="language-julia">predict(tuned, Xnew)</code></pre><pre><code class="language-none">3-element Array{UnivariateFinite{Multiclass{3},String,UInt32,Float64},1}:
 UnivariateFinite{Multiclass{3}}(versicolor=&gt;0.0, virginica=&gt;0.0, setosa=&gt;1.0)       
 UnivariateFinite{Multiclass{3}}(versicolor=&gt;0.0, virginica=&gt;0.0, setosa=&gt;1.0)       
 UnivariateFinite{Multiclass{3}}(versicolor=&gt;0.473, virginica=&gt;0.0333, setosa=&gt;0.493)</code></pre><h2 id="Constructing-a-linear-pipeline-1"><a class="docs-heading-anchor" href="#Constructing-a-linear-pipeline-1">Constructing a linear pipeline</a><a class="docs-heading-anchor-permalink" href="#Constructing-a-linear-pipeline-1" title="Permalink"></a></h2><p><em>Reference:</em>   <a href="../composing_models/">Composing Models</a></p><p>Constructing a linear (unbranching) pipeline with a <em>learned</em> target transformation/inverse transformation:</p><pre><code class="language-julia">X, y = @load_reduced_ames
@load KNNRegressor
pipe = @pipeline(X -&gt; coerce(X, :age=&gt;Continuous),
                 OneHotEncoder,
                 KNNRegressor(K=3),
                 target = UnivariateStandardizer)</code></pre><pre><code class="language-none">Pipeline377(
    one_hot_encoder = OneHotEncoder(
            features = Symbol[],
            drop_last = false,
            ordered_factor = true,
            ignore = false),
    knn_regressor = KNNRegressor(
            K = 3,
            algorithm = :kdtree,
            metric = Distances.Euclidean(0.0),
            leafsize = 10,
            reorder = true,
            weights = :uniform),
    target = UnivariateStandardizer()) @100</code></pre><p>Evaluating the pipeline (just as you would any other model):</p><pre><code class="language-julia">pipe.knn_regressor.K = 2
pipe.one_hot_encoder.drop_last = true
evaluate(pipe, X, y, resampling=Holdout(), measure=rms, verbosity=2)</code></pre><pre><code class="language-none">┌───────────────────────────┬───────────────┬────────────┐
│ _.measure                 │ _.measurement │ _.per_fold │
├───────────────────────────┼───────────────┼────────────┤
│ RootMeanSquaredError @125 │ 53100.0       │ [53100.0]  │
└───────────────────────────┴───────────────┴────────────┘
_.per_observation = [missing]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><p>Inspecting the learned parameters in a pipeline:</p><pre><code class="language-julia">mach = machine(pipe, X, y) |&gt; fit!
F = fitted_params(mach)
F.one_hot_encoder</code></pre><pre><code class="language-none">(fitresult = OneHotEncoderResult @668,)</code></pre><p>Constructing a linear (unbranching) pipeline with a <em>static</em> (unlearned) target transformation/inverse transformation:</p><pre><code class="language-julia">@load DecisionTreeRegressor
pipe2 = @pipeline(X -&gt; coerce(X, :age=&gt;Continuous),
                  OneHotEncoder,
                  DecisionTreeRegressor(max_depth=4),
                  target = y -&gt; log.(y),
                  inverse = z -&gt; exp.(z))</code></pre><pre><code class="language-none">Pipeline388(
    one_hot_encoder = OneHotEncoder(
            features = Symbol[],
            drop_last = false,
            ordered_factor = true,
            ignore = false),
    decision_tree_regressor = DecisionTreeRegressor(
            max_depth = 4,
            min_samples_leaf = 5,
            min_samples_split = 2,
            min_purity_increase = 0.0,
            n_subfeatures = 0,
            post_prune = false,
            merge_purity_threshold = 1.0),
    target = WrappedFunction(
            f = getfield(Main.ex-workflows, Symbol(&quot;##28#29&quot;))()),
    inverse = WrappedFunction(
            f = getfield(Main.ex-workflows, Symbol(&quot;##30#31&quot;))())) @293</code></pre><h2 id="Creating-a-homogeneous-ensemble-of-models-1"><a class="docs-heading-anchor" href="#Creating-a-homogeneous-ensemble-of-models-1">Creating a homogeneous ensemble of models</a><a class="docs-heading-anchor-permalink" href="#Creating-a-homogeneous-ensemble-of-models-1" title="Permalink"></a></h2><p><em>Reference:</em> <a href="../homogeneous_ensembles/">Homogeneous Ensembles</a></p><pre><code class="language-julia">X, y = @load_iris
tree_model = @load DecisionTreeClassifier
forest_model = EnsembleModel(atom=tree_model, bagging_fraction=0.8, n=300)
forest = machine(forest_model, X, y)
evaluate!(forest, measure=cross_entropy)</code></pre><pre><code class="language-none">┌───────────────────────┬───────────────┬───────────────────────────────────────
│ _.measure             │ _.measurement │ _.per_fold                           ⋯
├───────────────────────┼───────────────┼───────────────────────────────────────
│ LogLoss{Float64} @340 │ 0.426         │ [3.66e-15, 3.66e-15, 0.298, 0.384, 1 ⋯
└───────────────────────┴───────────────┴───────────────────────────────────────
                                                                1 column omitted
_.per_observation = [[[3.66e-15, 3.66e-15, ..., 3.66e-15], [3.66e-15, 3.66e-15, ..., 3.66e-15], [0.0408, 0.00334, ..., 3.66e-15], [3.66e-15, 0.223, ..., 3.66e-15], [3.66e-15, 0.0236, ..., 3.66e-15], [0.0236, 0.457, ..., 0.0339]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]
</code></pre><h2 id="Performance-curves-1"><a class="docs-heading-anchor" href="#Performance-curves-1">Performance curves</a><a class="docs-heading-anchor-permalink" href="#Performance-curves-1" title="Permalink"></a></h2><p>Generate a plot of performance, as a function of some hyperparameter (building on the preceding example)</p><p>Single performance curve:</p><pre><code class="language-julia">r = range(forest_model, :n, lower=1, upper=1000, scale=:log10)
curve = learning_curve(forest,
                            range=r,
                            resampling=Holdout(),
                            resolution=50,
                            measure=cross_entropy,
                            verbosity=0)</code></pre><pre><code class="language-none">(parameter_name = &quot;n&quot;,
 parameter_scale = :log10,
 parameter_values = [1, 2, 3, 4, 5, 6, 7, 8, 10, 11  …  281, 324, 373, 429, 494, 569, 655, 754, 869, 1000],
 measurements = [8.009700753137146, 8.009700753137146, 8.009700753137146, 8.009700753137146, 8.009700753137146, 8.009700753137146, 8.009700753137146, 8.009700753137146, 6.541087312054981, 6.542314459282158  …  1.2254237642269368, 1.2231654606456486, 1.222167573974167, 1.223480788585272, 1.2263276905616673, 1.2265903044524984, 1.230019472728071, 1.236109446724535, 1.2363352788735642, 1.2369387646418355],)</code></pre><pre><code class="language-julia">using Plots
plot(curve.parameter_values, curve.measurements, xlab=curve.parameter_name, xscale=curve.parameter_scale)</code></pre><p><img src="../img/workflows_learning_curve.png" alt/></p><p>Multiple curves:</p><pre><code class="language-julia">curve = learning_curve(forest,
                       range=r,
                       resampling=Holdout(),
                       measure=cross_entropy,
                       resolution=50,
                       rng_name=:rng,
                       rngs=4,
                       verbosity=0)</code></pre><pre><code class="language-none">(parameter_name = &quot;n&quot;,
 parameter_scale = :log10,
 parameter_values = [1, 2, 3, 4, 5, 6, 7, 8, 10, 11  …  281, 324, 373, 429, 494, 569, 655, 754, 869, 1000],
 measurements = [8.009700753137146 4.004850376568572 15.218431430960575 4.004850376568572; 8.009700753137146 4.004850376568572 15.218431430960575 4.004850376568572; … ; 1.1790908318093263 1.2076992366741803 1.2497796337975795 1.2474971607060312; 1.1841167221938287 1.212054914992999 1.250474807659648 1.2486197945744417],)</code></pre><pre><code class="language-julia">plot(curve.parameter_values, curve.measurements,
xlab=curve.parameter_name, xscale=curve.parameter_scale)</code></pre><p><img src="../img/workflows_learning_curves.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../working_with_categorical_data/">Working with Categorical Data »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 28 November 2020 00:07">Saturday 28 November 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
