<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Performance Measures · MLJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="MLJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">MLJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="tocitem" href="../working_with_categorical_data/">Working with Categorical Data</a></li><li><a class="tocitem" href="../model_search/">Model Search</a></li><li><a class="tocitem" href="../machines/">Machines</a></li><li><a class="tocitem" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li class="is-active"><a class="tocitem" href>Performance Measures</a><ul class="internal"><li><a class="tocitem" href="#Using-built-in-measures-1"><span>Using built-in measures</span></a></li><li><a class="tocitem" href="#Traits-and-custom-measures-1"><span>Traits and custom measures</span></a></li><li><a class="tocitem" href="#Using-measures-from-LossFunctions.jl-1"><span>Using measures from LossFunctions.jl</span></a></li><li><a class="tocitem" href="#Built-in-measures-1"><span>Built-in measures</span></a></li><li><a class="tocitem" href="#List-of-LossFunctions.jl-measures-1"><span>List of LossFunctions.jl measures</span></a></li><li><a class="tocitem" href="#Other-performance-related-tools-1"><span>Other performance related tools</span></a></li></ul></li><li><a class="tocitem" href="../tuning_models/">Tuning Models</a></li><li><a class="tocitem" href="../learning_curves/">Learning Curves</a></li><li><a class="tocitem" href="../transformers/">Transformers and other unsupervised models</a></li><li><a class="tocitem" href="../composing_models/">Composing Models</a></li><li><a class="tocitem" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="tocitem" href="../generating_synthetic_data/">Generating Synthetic Data</a></li><li><a class="tocitem" href="../openml_integration/">OpenML Integration</a></li><li><a class="tocitem" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="tocitem" href="../quick_start_guide_to_adding_models/">Quick-Start Guide to Adding Models</a></li><li><a class="tocitem" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../list_of_supported_models/">List of Supported Models</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="tocitem" href="../frequently_asked_questions/">FAQ</a></li><li><a class="tocitem" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="tocitem" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Performance Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Performance Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/performance_measures.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Performance-Measures-1"><a class="docs-heading-anchor" href="#Performance-Measures-1">Performance Measures</a><a class="docs-heading-anchor-permalink" href="#Performance-Measures-1" title="Permalink"></a></h1><p>In MLJ loss functions, scoring rules, sensitivities, and so on, are collectively referred to as <em>measures</em>. Presently, MLJ includes a few built-in measures, provides support for the loss functions in the <a href="https://github.com/JuliaML/LossFunctions.jl">LossFunctions.jl</a> library, and allows for users to define their own custom measures.</p><p>Providing further measures for probabilistic predictors, such as proper scoring rules, and for constructing multi-target product measures, is a work in progress.</p><p><em>Note for developers:</em> The measures interface and the built-in measures  described here are defined in MLJBase.</p><h2 id="Using-built-in-measures-1"><a class="docs-heading-anchor" href="#Using-built-in-measures-1">Using built-in measures</a><a class="docs-heading-anchor-permalink" href="#Using-built-in-measures-1" title="Permalink"></a></h2><p>These measures all have the common calling syntax</p><pre><code class="language-julia">measure(ŷ, y)</code></pre><p>or</p><pre><code class="language-julia">measure(ŷ, y, w)</code></pre><p>where <code>y</code> iterates over observations of some target variable, and <code>ŷ</code> iterates over predictions (<code>Distribution</code> or <code>Sampler</code> objects in the probabilistic case). Here <code>w</code> is an optional vector of sample weights, which can be provided when the measure supports this.</p><pre><code class="language-julia-repl">julia&gt; using MLJ

julia&gt; y = [1, 2, 3, 4];

julia&gt; ŷ = [2, 3, 3, 3];

julia&gt; w = [1, 2, 2, 1];

julia&gt; rms(ŷ, y) # reports an aggregrate loss
0.8660254037844386

julia&gt; l1(ŷ, y, w) # reports per observation losses
4-element Array{Int64,1}:
 1
 2
 0
 1

julia&gt; y = categorical([&quot;male&quot;, &quot;female&quot;, &quot;female&quot;])
3-element CategoricalArray{String,1,UInt32}:
 &quot;male&quot;
 &quot;female&quot;
 &quot;female&quot;

julia&gt; male = y[1]; female = y[2];

julia&gt; d = UnivariateFinite([male, female], [0.55, 0.45]);

julia&gt; ŷ = [d, d, d];

julia&gt; cross_entropy(ŷ, y)
3-element Array{Float64,1}:
 0.5978370007556204
 0.7985076962177716
 0.7985076962177716</code></pre><h2 id="Traits-and-custom-measures-1"><a class="docs-heading-anchor" href="#Traits-and-custom-measures-1">Traits and custom measures</a><a class="docs-heading-anchor-permalink" href="#Traits-and-custom-measures-1" title="Permalink"></a></h2><p>Notice that <code>l1</code> reports per-sample evaluations, while <code>rms</code> only reports an aggregated result. This and other behavior can be gleaned from measure <em>traits</em> which are summarized by the <code>info</code> method:</p><pre><code class="language-julia-repl">julia&gt; info(l1)
absolute deviations; aliases: `l1`.
(name = &quot;l1&quot;,
 target_scitype = Union{AbstractArray{Continuous,1}, AbstractArray{Count,1}},
 supports_weights = true,
 prediction_type = :deterministic,
 orientation = :loss,
 reports_each_observation = true,
 aggregation = MLJBase.Mean(),
 is_feature_dependent = false,
 docstring = &quot;absolute deviations; aliases: `l1`.&quot;,
 distribution_type = missing,)</code></pre><p>Use <code>measures()</code> to list all measures and <code>measures(conditions...)</code> to search for measures with given traits (as you would <a href="../model_search/">query models</a>).</p><article class="docstring"><header><a class="docstring-binding" id="MLJBase.measures-Tuple" href="#MLJBase.measures-Tuple"><code>MLJBase.measures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measures()</code></pre><p>List all measures as named-tuples keyed on measure traits.</p><pre><code class="language-none">measures(filters...)</code></pre><p>List all measures <code>m</code> for which <code>filter(m)</code> is true, for each <code>filter</code> in <code>filters</code>.</p><pre><code class="language-none">measures(matching(y))</code></pre><p>List all measures compatible with the target <code>y</code>.</p><pre><code class="language-none">measures(needle::Union{AbstractString,Regex}</code></pre><p>List all measures with <code>needle</code> in a measure&#39;s <code>name</code> or <code>docstring</code>.</p><p><strong>Example</strong></p><p>Find all classification measures supporting sample weights:</p><pre><code class="language-none">measures(m -&gt; m.target_scitype &lt;: AbstractVector{&lt;:Finite} &amp;&amp;
              m.supports_weights)</code></pre><p>Find all classification measures where the number of classes is three:</p><pre><code class="language-none">y  = categorical(1:3)
measures(matching(y))</code></pre><p>Find all measures in the <code>rms</code> family:</p><pre><code class="language-none">measures(&quot;rms&quot;)</code></pre></div></section></article><p>A user-defined measure in MLJ can be passed to the <code>evaluate!</code> method, and elsewhere in MLJ, provided it is a function or callable object conforming to the above syntactic conventions. By default, a custom measure is understood to:</p><ul><li><p>be a loss function (rather than a score)</p></li><li><p>report an aggregated value (rather than per-sample evaluations)</p></li><li><p>be feature-independent</p></li></ul><p>To override this behaviour one simply overloads the appropriate trait, as shown in the following examples:</p><pre><code class="language-julia-repl">julia&gt; y = [1, 2, 3, 4];

julia&gt; ŷ = [2, 3, 3, 3];

julia&gt; w = [1, 2, 2, 1];

julia&gt; my_loss(ŷ, y) = maximum((ŷ - y).^2);

julia&gt; my_loss(ŷ, y)
1

julia&gt; my_per_sample_loss(ŷ, y) = abs.(ŷ - y);

julia&gt; MLJ.reports_each_observation(::typeof(my_per_sample_loss)) = true;

julia&gt; my_per_sample_loss(ŷ, y)
4-element Array{Int64,1}:
 1
 1
 0
 1

julia&gt; my_weighted_score(ŷ, y) = 1/mean(abs.(ŷ - y));

julia&gt; my_weighted_score(ŷ, y, w) = 1/mean(abs.((ŷ - y).^w));

julia&gt; MLJ.supports_weights(::typeof(my_weighted_score)) = true;

julia&gt; MLJ.orientation(::typeof(my_weighted_score)) = :score;

julia&gt; my_weighted_score(ŷ, y)
1.3333333333333333

julia&gt; X = (x=rand(4), penalty=[1, 2, 3, 4]);

julia&gt; my_feature_dependent_loss(ŷ, X, y) = sum(abs.(ŷ - y) .* X.penalty)/sum(X.penalty);

julia&gt; MLJ.is_feature_dependent(::typeof(my_feature_dependent_loss)) = true

julia&gt; my_feature_dependent_loss(ŷ, X, y)
0.7</code></pre><p>The possible signatures for custom measures are: <code>measure(ŷ, y)</code>, <code>measure(ŷ, y, w)</code>, <code>measure(ŷ, X, y)</code> and <code>measure(ŷ, X, y, w)</code>, each measure implementing one non-weighted version, and possibly a second weighted version.</p><p><em>Implementation detail:</em> Internally, every measure is evaluated using the syntax</p><pre><code class="language-julia">MLJ.value(measure, ŷ, X, y, w)</code></pre><p>and the traits determine what can be ignored and how <code>measure</code> is actually called. If <code>w=nothing</code> then the non-weighted form of <code>measure</code> is dispatched.</p><h2 id="Using-measures-from-LossFunctions.jl-1"><a class="docs-heading-anchor" href="#Using-measures-from-LossFunctions.jl-1">Using measures from LossFunctions.jl</a><a class="docs-heading-anchor-permalink" href="#Using-measures-from-LossFunctions.jl-1" title="Permalink"></a></h2><p>The <a href="https://github.com/JuliaML/LossFunctions.jl">LossFunctions.jl</a> package includes &quot;distance loss&quot; functions for <code>Continuous</code> targets, and &quot;marginal loss&quot; functions for <code>Binary</code> targets. While the LossFunctions,jl interface differs from the present one (for, example <code>Binary</code> observations must be +1 or -1), one can safely pass the loss functions defined there to any MLJ algorithm, which re-interprets it under the hood. Note that the &quot;distance losses&quot; in the package apply to deterministic predictions, while the &quot;marginal losses&quot; apply to probabilistic predictions.</p><pre><code class="language-julia-repl">julia&gt; using LossFunctions

julia&gt; X = (x1=rand(5), x2=rand(5)); y = categorical([&quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;n&quot;, &quot;y&quot;]); w = [1, 2, 1, 2, 3];

julia&gt; mach = machine(ConstantClassifier(), X, y);

julia&gt; holdout = Holdout(fraction_train=0.6);

julia&gt; evaluate!(mach,
                 measure=[ZeroOneLoss(), L1HingeLoss(), L2HingeLoss(), SigmoidLoss()],
                 resampling=holdout,
                 operation=predict,
                 weights=w,
                 verbosity=0)
┌─────────────┬───────────────┬────────────┐
│ _.measure   │ _.measurement │ _.per_fold │
├─────────────┼───────────────┼────────────┤
│ ZeroOneLoss │ 0.4           │ [0.4]      │
│ L1HingeLoss │ 0.8           │ [0.8]      │
│ L2HingeLoss │ 1.6           │ [1.6]      │
│ SigmoidLoss │ 0.848         │ [0.848]    │
└─────────────┴───────────────┴────────────┘
_.per_observation = [[[0.8, 0.0]], [[1.6, 0.0]], [[3.2, 0.0]], [[1.409275324764612, 0.2860870128530822]]]
_.fitted_params_per_fold = [ … ]
_.report_per_fold = [ … ]</code></pre><p><em>Note:</em> Although <code>ZeroOneLoss(ŷ, y)</code> makes no sense (neither <code>ŷ</code> nor <code>y</code> have a type expected by LossFunctions.jl), one can instead use the adaptor <code>MLJ.value</code> as discussed above:</p><pre><code class="language-julia-repl">julia&gt; ŷ = predict(mach, X);

julia&gt; loss = MLJ.value(ZeroOneLoss(), ŷ, X, y, w) # X is ignored here
5-element Array{Float64,1}:
 0.0
 0.0
 0.0
 1.1111111111111112
 0.0

julia&gt; mean(loss) ≈ misclassification_rate(mode.(ŷ), y, w)
false</code></pre><h2 id="Built-in-measures-1"><a class="docs-heading-anchor" href="#Built-in-measures-1">Built-in measures</a><a class="docs-heading-anchor-permalink" href="#Built-in-measures-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.area_under_curve" href="#MLJBase.area_under_curve"><code>MLJBase.area_under_curve</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">area_under_curve</code></pre><p>Area under the ROC curve; aliases: <code>area_under_curve</code>, <code>auc</code></p><pre><code class="language-none">area_under_curve(ŷ, y)</code></pre><p>Return the area under the receiver operator characteristic (curve), for probabilistic predictions <code>ŷ</code>, given ground truth <code>y</code>. This metric is invariant to class labelling and can be used only for binary classification.</p><p>For more information, run <code>info(area_under_curve)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.accuracy" href="#MLJBase.accuracy"><code>MLJBase.accuracy</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">accuracy</code></pre><p>Classification accuracy; aliases: <code>accuracy</code>.</p><pre><code class="language-none">accuracy(ŷ, y)
accuracy(ŷ, y, w)
accuracy(conf_mat)</code></pre><p>Returns the accuracy of the (point) predictions <code>ŷ</code>, given true observations <code>y</code>, optionally weighted by the weights <code>w</code>. All three arguments must be abstract vectors of the same length. This metric is invariant to class labelling and can be used for multiclass classification.</p><p>For more information, run <code>info(accuracy)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.balanced_accuracy" href="#MLJBase.balanced_accuracy"><code>MLJBase.balanced_accuracy</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">balanced_accuracy</code></pre><p>Balanced classification accuracy; aliases: <code>balanced_accuracy</code>, <code>bacc</code>, <code>bac</code>.</p><pre><code class="language-none">balanced_accuracy(ŷ, y [, w])
balanced_accuracy(conf_mat)</code></pre><p>Return the balanced accuracy of the point prediction <code>ŷ</code>, given true observations <code>y</code>, optionally weighted by <code>w</code>. The balanced accuracy takes into consideration class imbalance. All  three arguments must have the same length. This metric is invariant to class labelling and can be used for multiclass classification.</p><p>For more information, run <code>info(balanced_accuracy)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.BrierScore" href="#MLJBase.BrierScore"><code>MLJBase.BrierScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BrierScore(; distribution=UnivariateFinite)(ŷ, y [, w])</code></pre><p>Given an abstract vector of distributions <code>ŷ</code> of type <code>distribution</code>, and an abstract vector of true observations <code>y</code>, return the corresponding Brier (aka quadratic) scores. Weight the scores using <code>w</code> if provided.</p><p>Currently only <code>distribution=UnivariateFinite</code> is supported, which is applicable to superivised models with <code>Finite</code> target scitype. In this case, if <code>p(y)</code> is the predicted probability for a <em>single</em> observation <code>y</code>, and <code>C</code> all possible classes, then the corresponding Brier score for that observation is given by</p><p><span>$2p(y) - \left(\sum_{η ∈ C} p(η)^2\right) - 1$</span></p><p>Note that <code>BrierScore()=BrierScore{UnivariateFinite}</code> has the alias <code>brier_score</code>.</p><p><em>Warning.</em> Here <code>BrierScore</code> is a &quot;score&quot; in the sense that bigger is better (with <code>0</code> optimal, and all other values negative). In Brier&#39;s original 1950 paper, and many other places, it has the opposite sign, despite the name. Moreover, the present implementation does not treat the binary case as special, so that the score may differ, in that case, by a factor of two from usage elsewhere.</p><p>For more information, run <code>info(BrierScore)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.cross_entropy" href="#MLJBase.cross_entropy"><code>MLJBase.cross_entropy</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">cross_entropy</code></pre><p>Cross entropy loss with probabilities clamped between <code>eps()</code> and <code>1-eps()</code>; aliases: <code>cross_entropy</code>.</p><pre><code class="language-none">ce = CrossEntropy(; eps=eps())
ce(ŷ, y)</code></pre><p>Given an abstract vector of distributions <code>ŷ</code> and an abstract vector of true observations <code>y</code>, return the corresponding cross-entropy loss (aka log loss) scores.</p><p>Since the score is undefined in the case of the true observation has predicted probability zero, probablities are clipped between <code>eps</code> and <code>1-eps</code> where <code>eps</code> can be specified.</p><p>If <code>sᵢ</code> is the predicted probability for the true class <code>yᵢ</code> then the score for that example is given by</p><pre><code class="language-none">-log(clamp(sᵢ, eps, 1-eps))</code></pre><p>For more information, run <code>info(cross_entropy)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.FScore" href="#MLJBase.FScore"><code>MLJBase.FScore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FScore{β}(rev=nothing)</code></pre><p>One-parameter generalization, <span>$F_β$</span>, of the F-measure or balanced F-score.</p><p><a href="https://en.wikipedia.org/wiki/F1_score">Wikipedia entry</a></p><pre><code class="language-none">FScore{β}(ŷ, y)</code></pre><p>Evaluate <span>$F_β$</span> score on observations ,<code>ŷ</code>, given ground truth values, <code>y</code>.</p><p>By default, the second element of <code>levels(y)</code> is designated as <code>true</code>. To reverse roles, use <code>FScore{β}(rev=true)</code> instead of <code>FScore{β}</code>.</p><p>For more information, run <code>info(FScore)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.false_discovery_rate" href="#MLJBase.false_discovery_rate"><code>MLJBase.false_discovery_rate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">false_discovery_rate</code></pre><p>false discovery rate; aliases: <code>false_discovery_rate</code>, <code>falsediscovery_rate</code>, <code>fdr</code>.</p><pre><code class="language-none">false_discovery_rate(ŷ, y)</code></pre><p>False discovery rate for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>FalseDiscoveryRate(rev=true)</code> instead of <code>false_discovery_rate</code>.</p><p>For more information, run <code>info(false_discovery_rate)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.false_negative" href="#MLJBase.false_negative"><code>MLJBase.false_negative</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">false_negative</code></pre><p>Number of false negatives; aliases: <code>false_negative</code>, <code>falsenegative</code>.</p><pre><code class="language-none">false_negative(ŷ, y)</code></pre><p>Number of false positives for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>FalseNegative(rev=true)</code> instead of <code>false_negative</code>.</p><p>For more information, run <code>info(false_negative)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.false_negative_rate" href="#MLJBase.false_negative_rate"><code>MLJBase.false_negative_rate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">false_negative_rate</code></pre><p>false negative rate; aliases: <code>false_negative_rate</code>, <code>falsenegative_rate</code>, <code>fnr</code>, <code>miss_rate</code>.</p><pre><code class="language-none">false_negative_rate(ŷ, y)</code></pre><p>False negative rate for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>FalseNegativeRate(rev=true)</code> instead of <code>false_negative_rate</code>.</p><p>For more information, run <code>info(false_negative_rate)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.false_positive" href="#MLJBase.false_positive"><code>MLJBase.false_positive</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">false_positive</code></pre><p>Number of false positives; aliases: <code>false_positive</code>, <code>falsepositive</code>.</p><pre><code class="language-none">false_positive(ŷ, y)</code></pre><p>Number of false positives for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>FalsePositive(rev=true)</code> instead of <code>false_positive</code>.</p><p>For more information, run <code>info(false_positive)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.false_positive_rate" href="#MLJBase.false_positive_rate"><code>MLJBase.false_positive_rate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">false_positive_rate</code></pre><p>false positive rate; aliases: <code>false_positive_rate</code>, <code>falsepositive_rate</code>, <code>fpr</code>, <code>fallout</code>.</p><pre><code class="language-none">false_positive_rate(ŷ, y)</code></pre><p>False positive rate for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>FalsePositiveRate(rev=true)</code> instead of <code>false_positive_rate</code>.</p><p>For more information, run <code>info(false_positive_rate)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.l1" href="#MLJBase.l1"><code>MLJBase.l1</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">l1(ŷ, y)
l1(ŷ, y, w)</code></pre><p>L1 per-observation loss.</p><p>For more information, run <code>info(l1)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.l2" href="#MLJBase.l2"><code>MLJBase.l2</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">l2(ŷ, y)
l2(ŷ, y, w)</code></pre><p>L2 per-observation loss.</p><p>For more information, run <code>info(l2)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.mae" href="#MLJBase.mae"><code>MLJBase.mae</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">mae(ŷ, y)
mae(ŷ, y, w)</code></pre><p>Mean absolute error.</p><p><span>$\text{MAE} =  n^{-1}∑ᵢ|yᵢ-ŷᵢ|$</span> or <span>$\text{MAE} = n^{-1}∑ᵢwᵢ|yᵢ-ŷᵢ|$</span></p><p>For more information, run <code>info(mae)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.matthews_correlation" href="#MLJBase.matthews_correlation"><code>MLJBase.matthews_correlation</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">matthews_correlation</code></pre><p>Matthew&#39;s correlation; aliases: <code>matthews_correlation</code>, <code>mcc</code></p><pre><code class="language-none">matthews_correlation(ŷ, y)
matthews_correlation(conf_mat)</code></pre><p>Return Matthews&#39; correlation coefficient corresponding to the point prediction <code>ŷ</code>, given true observations <code>y</code>. This metric is invariant to class labelling and can be used for multiclass classification.</p><p>For more information, run <code>info(matthews_correlation)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.misclassification_rate" href="#MLJBase.misclassification_rate"><code>MLJBase.misclassification_rate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">misclassification_rate</code></pre><p>misclassification rate; aliases: <code>misclassification_rate</code>, <code>mcr</code>.</p><pre><code class="language-none">misclassification_rate(ŷ, y)
misclassification_rate(ŷ, y, w)
misclassification_rate(conf_mat)</code></pre><p>Returns the rate of misclassification of the (point) predictions <code>ŷ</code>, given true observations <code>y</code>, optionally weighted by the weights <code>w</code>. All three arguments must be abstract vectors of the same length. A confusion matrix can also be passed as argument. This metric is invariant to class labelling and can be used for multiclass classification.</p><p>For more information, run <code>info(misclassification_rate)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.negative_predictive_value" href="#MLJBase.negative_predictive_value"><code>MLJBase.negative_predictive_value</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">negative_predictive_value</code></pre><p>negative predictive value; aliases: <code>negative_predictive_value</code>, <code>negativepredictive_value</code>, <code>npv</code>.</p><pre><code class="language-none">negative_predictive_value(ŷ, y)</code></pre><p>Negative predictive value for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>NPV(rev=true)</code> instead of <code>negative_predictive_value</code>.</p><p>For more information, run <code>info(negative_predictive_value)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.positive_predictive_value" href="#MLJBase.positive_predictive_value"><code>MLJBase.positive_predictive_value</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">positive_predictive_value</code></pre><p>positive predictive value (aka precision); aliases: <code>positive_predictive_value</code>, <code>ppv</code>, <code>Precision()</code>, <code>positivepredictive_value</code>. </p><pre><code class="language-none">positive_predictive_value(ŷ, y)</code></pre><p>Positive predictive value for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>Precision(rev=true)</code> instead of <code>positive_predictive_value</code>.</p><p>For more information, run <code>info(positive_predictive_value)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.rms" href="#MLJBase.rms"><code>MLJBase.rms</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">rms(ŷ, y)
rms(ŷ, y, w)</code></pre><p>Root mean squared error:</p><p><span>$\text{RMS} = \sqrt{n^{-1}∑ᵢ|yᵢ-ŷᵢ|^2}$</span> or <span>$\text{RMS} = \sqrt{\frac{∑ᵢwᵢ|yᵢ-ŷᵢ|^2}{∑ᵢwᵢ}}$</span></p><p>For more information, run <code>info(rms)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.rmsl" href="#MLJBase.rmsl"><code>MLJBase.rmsl</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">rmsl(ŷ, y)</code></pre><p>Root mean squared logarithmic error:</p><p><span>$\text{RMSL} = n^{-1}∑ᵢ\log\left({yᵢ \over ŷᵢ}\right)$</span></p><p>For more information, run <code>info(rmsl)</code>.</p><p>See also <a href="#MLJBase.rmslp1"><code>rmslp1</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.rmslp1" href="#MLJBase.rmslp1"><code>MLJBase.rmslp1</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">rmslp1(ŷ, y)</code></pre><p>Root mean squared logarithmic error with an offset of 1:</p><p><span>$\text{RMSLP1} = n^{-1}∑ᵢ\log\left({yᵢ + 1 \over ŷᵢ + 1}\right)$</span></p><p>For more information, run <code>info(rmslp1)</code>.</p><p>See also <a href="#MLJBase.rmsl"><code>rmsl</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.rmsp" href="#MLJBase.rmsp"><code>MLJBase.rmsp</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">rmsp(ŷ, y)</code></pre><p>Root mean squared proportional loss:</p><p><span>$\text{RMSP} = m^{-1}∑ᵢ \left({yᵢ-ŷᵢ \over yᵢ}\right)^2$</span></p><p>where the sum is over indices such that <code>yᵢ≂̸0</code> and <code>m</code> is the number of such indices.</p><p>For more information, run <code>info(rmsp)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.true_negative" href="#MLJBase.true_negative"><code>MLJBase.true_negative</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">true_negative</code></pre><p>Number of true negatives; aliases: <code>true_negative</code>, <code>truenegative</code>.</p><pre><code class="language-none">true_negative(ŷ, y)</code></pre><p>Number of true negatives for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>TrueNegative(rev=true)</code> instead of <code>true_negative</code>.</p><p>For more information, run <code>info(true_negative)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.true_negative_rate" href="#MLJBase.true_negative_rate"><code>MLJBase.true_negative_rate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">true_negative_rate</code></pre><p>true negative rate; aliases: <code>true_negative_rate</code>, <code>truenegative_rate</code>, <code>tnr</code>, <code>specificity</code>, <code>selectivity</code>.</p><pre><code class="language-none">true_negative_rate(ŷ, y)</code></pre><p>True negative rate for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>TrueNegativeRate(rev=true)</code> instead of <code>true_negative_rate</code>.</p><p>For more information, run <code>info(true_negative_rate)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.true_positive" href="#MLJBase.true_positive"><code>MLJBase.true_positive</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">true_positive</code></pre><p>Number of true positives; aliases: <code>true_positive</code>, <code>truepositive</code>.</p><pre><code class="language-none">true_positive(ŷ, y)</code></pre><p>Number of true positives for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>TruePositive(rev=true)</code> instead of <code>true_positive</code>.</p><p>For more information, run <code>info(true_positive)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.true_positive_rate" href="#MLJBase.true_positive_rate"><code>MLJBase.true_positive_rate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">true_positive_rate</code></pre><p>True positive rate; aliases: <code>true_positive_rate</code>, <code>truepositive_rate</code>, <code>tpr</code>, <code>sensitivity</code>, <code>recall</code>, <code>hit_rate</code>.</p><pre><code class="language-none">true_positive_rate(ŷ, y)</code></pre><p>True positive rate for observations <code>ŷ</code> and ground truth <code>y</code>. Assigns <code>false</code> to first element of <code>levels(y)</code>. To reverse roles, use <code>TruePositiveRate(rev=true)</code> instead of <code>true_positive_rate</code>.</p><p>For more information, run <code>info(true_positive_rate)</code>.</p></div></section></article><h2 id="List-of-LossFunctions.jl-measures-1"><a class="docs-heading-anchor" href="#List-of-LossFunctions.jl-measures-1">List of LossFunctions.jl measures</a><a class="docs-heading-anchor-permalink" href="#List-of-LossFunctions.jl-measures-1" title="Permalink"></a></h2><p><code>DWDMarginLoss()</code>, <code>ExpLoss()</code>, <code>L1HingeLoss()</code>, <code>L2HingeLoss()</code>, <code>L2MarginLoss()</code>, <code>LogitMarginLoss()</code>, <code>ModifiedHuberLoss()</code>, <code>PerceptronLoss()</code>, <code>ScaledMarginLoss()</code>, <code>SigmoidLoss()</code>, <code>SmoothedL1HingeLoss()</code>, <code>ZeroOneLoss()</code>, <code>HuberLoss()</code>, <code>L1EpsilonInsLoss()</code>, <code>L2EpsilonInsLoss()</code>, <code>LPDistLoss()</code>, <code>LogitDistLoss()</code>, <code>PeriodicLoss()</code>, <code>QuantileLoss()</code>, <code>ScaledDistanceLoss()</code>.</p><h2 id="Other-performance-related-tools-1"><a class="docs-heading-anchor" href="#Other-performance-related-tools-1">Other performance related tools</a><a class="docs-heading-anchor-permalink" href="#Other-performance-related-tools-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLJBase.confusion_matrix" href="#MLJBase.confusion_matrix"><code>MLJBase.confusion_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">confusion_matrix(ŷ, y; rev=false)</code></pre><p>Computes the confusion matrix given a predicted <code>ŷ</code> with categorical elements and the actual <code>y</code>. Rows are the predicted class, columns the ground truth. The ordering follows that of <code>levels(y)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>rev=false</code>: in the binary case, this keyword allows to swap the ordering of              classes.</li><li><code>perm=[]</code>:   in the general case, this keyword allows to specify a permutation              re-ordering the classes.</li><li><code>warn=true</code>: whether to show a warning in case <code>y</code> does not have scientific              type <code>OrderedFactor{2}</code> (see note below).</li></ul><p><strong>Note</strong></p><p>To decrease the risk of unexpected errors, if <code>y</code> does not have scientific type <code>OrderedFactor{2}</code> (and so does not have a &quot;natural ordering&quot; negative-positive), a warning is shown indicating the current order unless the user explicitly specifies either <code>rev</code> or <code>perm</code> in which case it&#39;s assumed the user is aware of the class ordering.</p><p>The <code>confusion_matrix</code> is a measure (although neither a score nor a loss) and so may be specified as such in calls to <code>evaluate</code>, <code>evaluate!</code>, although not in <code>TunedModel</code>s.  In this case, however, there no way to specify an ordering different from <code>levels(y)</code>, where <code>y</code> is the target. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJBase.roc_curve" href="#MLJBase.roc_curve"><code>MLJBase.roc_curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fprs, tprs, ts = roc_curve(ŷ, y) = roc(ŷ, y)</code></pre><p>Return the ROC curve for a two-class probabilistic prediction <code>ŷ</code> given the ground  truth <code>y</code>. The true positive rates, false positive rates over a range of thresholds <code>ts</code> are returned. Note that if there are <code>k</code> unique scores, there are correspondingly  <code>k</code> thresholds and <code>k+1</code> &quot;bins&quot; over which the FPR and TPR are constant:</p><ul><li><code>[0.0 - thresh[1]]</code></li><li><code>[thresh[1] - thresh[2]]</code></li><li>...</li><li><code>[thresh[k] - 1]</code></li></ul><p>consequently, <code>tprs</code> and <code>fprs</code> are of length <code>k+1</code> if <code>ts</code> is of length <code>k</code>.</p><p>To draw the curve using your favorite plotting backend, do <code>plot(fprs, tprs)</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../evaluating_model_performance/">« Evaluating Model Performance</a><a class="docs-footer-nextpage" href="../tuning_models/">Tuning Models »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 October 2020 04:39">Monday 12 October 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
